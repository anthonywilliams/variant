// -*- C++ -*-
// Copyright (c) 2015, Just Software Solutions Ltd
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or
// without modification, are permitted provided that the
// following conditions are met:
//
// 1. Redistributions of source code must retain the above
// copyright notice, this list of conditions and the following
// disclaimer.
//
// 2. Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following
// disclaimer in the documentation and/or other materials
// provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of
// its contributors may be used to endorse or promote products
// derived from this software without specific prior written
// permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
// CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#ifndef _JSS_EXPERIMENTAL_VARIANT_HEADER
#define _JSS_EXPERIMENTAL_VARIANT_HEADER
#include <stddef.h>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <new>
#include <utility>

namespace std{
namespace experimental{

struct empty_t{};

template<typename _Type>
struct emplaced_type_t{};

template<ptrdiff_t _Index>
struct emplaced_index_t{};

class bad_variant_access: public std::logic_error{
public:
    explicit bad_variant_access(const std::string& what_arg):
        std::logic_error(what_arg)
    {}
    explicit bad_variant_access(const char* what_arg):
        std::logic_error(what_arg)
    {}
};

template<ptrdiff_t _Offset,typename _Type,typename ... _Types>
struct __type_index_helper;

template<ptrdiff_t _Offset,typename _Type,typename _Head,typename ... _Rest>
struct __type_index_helper<_Offset,_Type,_Head,_Rest...>{
    static constexpr ptrdiff_t __value=
        __type_index_helper<_Offset+1,_Type,_Rest...>::__value;
};

template<ptrdiff_t _Offset,typename _Type,typename ... _Rest>
struct __type_index_helper<_Offset,_Type,_Type,_Rest...>{
    static constexpr ptrdiff_t __value=_Offset;
};

template<typename _Type,typename ... _Types>
struct __type_index{
    static constexpr ptrdiff_t __value=
        __type_index_helper<0,_Type,_Types...>::__value;
};

template<typename ... _Types>
struct __type_index<empty_t,_Types...>{
    static constexpr ptrdiff_t __value=-1;
};



template<ptrdiff_t _Index,typename ... _Types>
struct __indexed_type;

template<typename ... _Types>
struct __indexed_type<-1,_Types...>{
    typedef empty_t __type;
};

template<typename _Head,typename ... _Rest>
struct __indexed_type<-1,_Head,_Rest...>{
    typedef empty_t __type;
};

template<typename _Head,typename ... _Rest>
struct __indexed_type<0,_Head,_Rest...>{
    typedef _Head __type;
};

template<ptrdiff_t _Index,typename _Head,typename ... _Rest>
struct __indexed_type<_Index,_Head,_Rest...>{
    typedef typename __indexed_type<_Index-1,_Rest...>::__type __type;
};

template<ptrdiff_t _Index,typename ..._Types>
struct __next_index{
    static constexpr ptrdiff_t __value=
        (_Index>=ptrdiff_t(sizeof...(_Types)-1))?-1:_Index+1;
};

template<typename ... _Types>
class variant;

template<typename _Type,typename ... _Types>
constexpr _Type& get(variant<_Types...>&);

template<typename _Type,typename ... _Types>
constexpr _Type const& get(variant<_Types...> const&);

template<ptrdiff_t _Index,typename ... _Types>
constexpr typename __indexed_type<_Index,_Types...>::__type& get(variant<_Types...>&);

template<ptrdiff_t _Index,typename ... _Types>
constexpr typename __indexed_type<_Index,_Types...>::__type const& get(
    variant<_Types...> const&);

template<ptrdiff_t _Index,typename ... _Types>
struct __variant_accessor;

template<size_t __count>
struct __descriminator_type{
    typedef signed char __type;
};

template<typename _Type>
struct __stored_type{
    typedef _Type __type;
    template<typename ... _Args>
    static constexpr void __construct(void* __storage,_Args&& ... __args){
        new (__storage) _Type(std::forward<_Args>(__args)...);
    }

    static constexpr _Type& __get(void* __storage){
        return *static_cast<__type*>(__storage);
    }

    static constexpr const _Type& __get(const void* __storage){
        return *static_cast<const __type*>(__storage);
    }
    
    static void __destroy(void* __storage){
        static_cast<__type*>(__storage)->~__type();
    }
};

template<typename _Type>
struct __stored_type<_Type&>{
    typedef _Type* __type;

    template<typename  _Arg>
    static constexpr void __construct(void* __storage,_Arg& __arg){
        new (__storage) __type(&__arg);
    }

    static constexpr _Type& __get(void* __storage){
        return **static_cast<__type*>(__storage);
    }

    static constexpr const _Type& __get(const void* __storage){
        return **static_cast<const __type*>(__storage);
    }
    
    static void __destroy(void* __storage){
        static_cast<__type*>(__storage)->~__type();
    }
};

template<typename ... _Types>
struct __all_trivially_destructible;

template<typename _Type>
struct __all_trivially_destructible<_Type> {
    static constexpr bool __value=
        std::is_trivially_destructible<typename __stored_type<_Type>::__type>::value;
};

template<typename ... _Types>
union __variant_data;

template<typename _Type,bool=std::is_literal_type<_Type>::value>
struct __variant_storage{
    typedef _Type __type;

    static constexpr _Type& __get(__type& __val){
        return __val;
    }
    static constexpr const _Type& __get(__type const& __val){
        return __val;
    }
};

struct __dummy_base{
    template<typename _Type>
    constexpr __dummy_base(_Type){}
};

template<typename _Type>
struct __storage_wrapper:__dummy_base{
    typename std::aligned_storage<sizeof(_Type),alignof(_Type)>::type __storage;

    template<typename ... _Args>
    static constexpr empty_t __construct(void* __p,_Args&& ... __args){
        return new (__p) _Type(std::forward<_Args>(__args)...),empty_t();
    }

    template<typename ... _Args>
    constexpr __storage_wrapper(_Args&& ... __args):
        __dummy_base(__construct(&__storage,std::forward<_Args>(__args)...)){}

    _Type& __get(){
        return *static_cast<_Type*>(static_cast<void*>(&__storage));
    }
    constexpr _Type const& __get() const{
        return *static_cast<_Type const*>(static_cast<void const*>(&__storage));
    }
};

template<typename _Type>
struct __storage_wrapper<_Type&>{
    _Type* __storage;

    template<typename _Arg>
    constexpr __storage_wrapper(_Arg& __arg):
        __storage(&__arg){}

    _Type& __get(){
        return *__storage;
    }
    constexpr _Type const& __get() const{
        return *__storage;
    }
};

template<typename _Type>
struct __variant_storage<_Type,false>{
    typedef __storage_wrapper<_Type> __type;

    static constexpr _Type& __get(__type& __val){
        return __val.__get();
    }
    static constexpr const _Type& __get(__type const& __val){
        return __val.__get();
    }
};

template<typename _Type,bool __b>
struct __variant_storage<_Type&,__b>{
    typedef __storage_wrapper<_Type&> __type;

    static constexpr _Type& __get(__type& __val){
        return __val.__get();
    }
    static constexpr const _Type& __get(__type const& __val){
        return __val.__get();
    }
};

template<typename _Type>
union __variant_data<_Type>{
    empty_t __dummy;
    typename __variant_storage<_Type>::__type __val;

    constexpr __variant_data():
        __dummy(){}
    
    template<typename ... _Args>
    constexpr __variant_data(emplaced_index_t<0>,_Args&& ... __args):
        __val(std::forward<_Args>(__args)...){}

    _Type& __get(emplaced_index_t<0>){
        return __variant_storage<_Type>::__get(__val);
    }
    constexpr const _Type& __get(emplaced_index_t<0>) const{
        return __variant_storage<_Type>::__get(__val);
    }
};

template<typename _Head,typename ... _Rest>
union __variant_data<_Head,_Rest...>{
    __variant_data<_Head> __head;
    __variant_data<_Rest...> __rest;

    constexpr __variant_data():
        __head(){}
    
    template<typename ... _Args>
    constexpr __variant_data(emplaced_index_t<0>,_Args&& ... __args):
        __head(emplaced_index_t<0>(),std::forward<_Args>(__args)...){}
    template<ptrdiff_t _Index,typename ... _Args>
    constexpr __variant_data(emplaced_index_t<_Index>,_Args&& ... __args):
        __rest(emplaced_index_t<_Index-1>(),std::forward<_Args>(__args)...){}

    _Head& __get(emplaced_index_t<0>){
        return __head.__get(emplaced_index_t<0>());
    }

    constexpr const _Head& __get(emplaced_index_t<0>) const{
        return __head.__get(emplaced_index_t<0>());
    }

    template<ptrdiff_t _Index>
    typename __indexed_type<_Index-1,_Rest...>::__type& __get(
        emplaced_index_t<_Index>){
        return __rest.__get(emplaced_index_t<_Index-1>());
    }
    template<ptrdiff_t _Index>
    constexpr const typename __indexed_type<_Index-1,_Rest...>::__type& __get(
        emplaced_index_t<_Index>) const{
        return __rest.__get(emplaced_index_t<_Index-1>());
    }
};


template<typename _Head,typename ... _Rest>
struct __all_trivially_destructible<_Head,_Rest...> {
    static constexpr bool __value=
        __all_trivially_destructible<_Head>::__value &&
        __all_trivially_destructible<_Rest...>::__value;
};

template<typename ... _Types>
struct __variant_ops{
    typedef variant<_Types...> __variant_type;
    typedef void(*__copy_func_type)(__variant_type*,__variant_type const&);
    typedef void(*__move_func_type)(__variant_type*,__variant_type&);
    typedef void(*__unary_func_type)(__variant_type*);
    typedef bool(*__compare_func_type)(__variant_type const&,__variant_type const&);

    template<typename _Type>
    static void __copy_construct_func(
        __variant_type* __self,__variant_type const& __other){
        __stored_type<_Type>::__construct(
            &__self->__storage,
            __stored_type<_Type>::__get(&__other.__storage));
    }

    template<typename _Type>
    static void __move_construct_func(
        __variant_type* __self,__variant_type& __other){
        __stored_type<_Type>::__construct(
            &__self->__storage,
            std::move(__stored_type<_Type>::__get(&__other.__storage)));
    }
    
    template<typename _Type>
    static void __copy_assign_func(
        __variant_type* __self,__variant_type const& __other){
        get<_Type>(*__self)=get<_Type>(__other);
    }

    template<typename _Type>
    static void __move_assign_func(
        __variant_type* __self,__variant_type& __other){
        get<_Type>(*__self)=std::move(get<_Type>(__other));
        __other.__destroy_self();
    }

    template<typename _Type>
    static void __destroy_func(__variant_type* __self){
        __stored_type<_Type>::__destroy(&__self->__storage);
    }
    
    template<typename _Type>
    static void __swap_func(
        __variant_type* __self,__variant_type& __other){
        swap(get<_Type>(*__self),get<_Type>(__other));
    }

    template<typename _Type>
    static bool __equality_compare_func(
        __variant_type const& __lhs,__variant_type const& __rhs){
        return get<_Type>(__lhs)==get<_Type>(__rhs);
    }

    template<typename _Type>
    static bool __less_than_compare_func(
        __variant_type const& __lhs,__variant_type const& __rhs){
        return get<_Type>(__lhs)<get<_Type>(__rhs);
    }
    
    static constexpr __copy_func_type __copy_construct[sizeof...(_Types)]={
        &__copy_construct_func<_Types>...
    };
    static constexpr __move_func_type __move_construct[sizeof...(_Types)]={
        &__move_construct_func<_Types>...
    };
    static constexpr __copy_func_type __copy_assign[sizeof...(_Types)]={
        &__copy_assign_func<_Types>...
    };
    static constexpr __move_func_type __move_assign[sizeof...(_Types)]={
        &__move_assign_func<_Types>...
    };
    static constexpr __move_func_type __swap[sizeof...(_Types)]={
        &__swap_func<_Types>...
    };
    static constexpr __unary_func_type __destroy[sizeof...(_Types)]={
        &__destroy_func<_Types>...
    };
    static constexpr __compare_func_type __equality_compare[sizeof...(_Types)]={
        &__equality_compare_func<_Types>...
    };
    static constexpr __compare_func_type __less_than_compare[sizeof...(_Types)]={
        &__less_than_compare_func<_Types>...
    };
};

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__copy_func_type
__variant_ops<_Types...>::__copy_construct[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__move_func_type
__variant_ops<_Types...>::__move_construct[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__copy_func_type
__variant_ops<_Types...>::__copy_assign[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__move_func_type
__variant_ops<_Types...>::__move_assign[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__move_func_type
__variant_ops<_Types...>::__swap[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__unary_func_type
__variant_ops<_Types...>::__destroy[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__compare_func_type
__variant_ops<_Types...>::__equality_compare[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__compare_func_type
__variant_ops<_Types...>::__less_than_compare[sizeof...(_Types)];

template<typename _Derived,bool __trivial_destructor>
struct __variant_base: empty_t
{
    ~__variant_base(){
        static_cast<_Derived*>(this)->__destroy_self();
    }
};

template<typename _Derived>
struct __variant_base<_Derived,true>:empty_t{
};

template<typename ... _Types>
class variant: private __variant_base<variant<_Types...>,__all_trivially_destructible<_Types...>::__value>{
    typedef __variant_base<variant<_Types...>,__all_trivially_destructible<_Types...>::__value> __base_type;
    friend __base_type;
    friend struct __variant_ops<_Types...>;
    
    template<ptrdiff_t _Index,typename ... _Types2>
    friend struct __variant_accessor;

    __variant_data<_Types...> __storage;
    typename __descriminator_type<sizeof ... (_Types)>::__type __index;

    template<typename _Type,typename ... _Args>
    ptrdiff_t __emplace_construct(_Args&& ... __args){
        __stored_type<_Type>::__construct(
            &__storage,std::forward<_Args>(__args)...);
        return  __type_index<_Type,_Types...>::__value;
    }
    
    void __destroy_self(){
        if(__index==-1)
            return;
        ptrdiff_t const __old_index=__index;
        __index=-1;
        __variant_ops<_Types...>::__destroy[__old_index](this);
    }
    
    ptrdiff_t __move_construct(variant& __other){
        ptrdiff_t const __other_index=__other.index();
        if(__other_index==-1)
            return -1;
        __variant_ops<_Types...>::__move_construct[__other_index](this,__other);
        __other.__destroy_self();
        return __other_index;
    }

    ptrdiff_t __copy_construct(variant const& __other){
        ptrdiff_t const __other_index=__other.index();
        if(__other_index==-1)
            return -1;
        __variant_ops<_Types...>::__copy_construct[__other_index](this,__other);
        return __other_index;
    }
    
public:
    constexpr variant() noexcept:
        __index(-1)
    {}

    constexpr variant(variant&& __other):
        __index(__move_construct(__other))
    {}

    constexpr variant(variant& __other):
        __index(__copy_construct(__other))
    {}

    constexpr variant(variant const& __other):
        __index(__copy_construct(__other))
    {}

    template<typename _Type,typename ... _Args>
    explicit constexpr variant(emplaced_type_t<_Type>,_Args&& ... __args):
        __storage(
            emplaced_index_t<__type_index<_Type,_Types...>::__value>(),
            std::forward<_Args>(__args)...),
        __index(__type_index<_Type,_Types...>::__value)
    {}

    template<ptrdiff_t _Index,typename ... _Args>
    explicit constexpr variant(emplaced_index_t<_Index>,_Args&& ... __args):
        __storage(emplaced_index_t<_Index>(),std::forward<_Args>(__args)...),
        __index(_Index)
    {}
    
    template<typename _Type>
    constexpr variant(_Type&& __x):
        __storage(
            emplaced_index_t<
            __type_index<typename std::remove_const<
            typename std::remove_reference<_Type>::type>::type,_Types...>::__value>(),
            std::forward<_Type>(__x)),
        __index(
            __type_index<typename std::remove_const<
            typename std::remove_reference<_Type>::type>::type,_Types...>::__value)
    {}

    template<typename _Type>
    variant& operator=(_Type&& __x){
        typedef typename std::remove_const<
            typename std::remove_reference<_Type>::type>::type __type;
        constexpr ptrdiff_t _Index=__type_index<__type,_Types...>::__value;
        if(_Index==__index){
            get<_Index>(*this)=std::forward<_Type>(__x);
        }
        else{
            __destroy_self();
            __stored_type<__type>::__construct(&__storage,std::forward<_Type>(__x));
            __index=_Index;
        }
        return *this;
    }

    variant& operator=(variant const& __other){
        if(__other.__index==-1){
            __destroy_self();
        }
        else if(__other.__index==__index){
            __variant_ops<_Types...>::__copy_assign[__index](this,__other);
        }
        else{
            __destroy_self();
            __index=__copy_construct(__other);
        }
        return *this;
    }
    variant& operator=(variant& __other){
        if(__other.__index==-1){
            __destroy_self();
        }
        else if(__other.__index==__index){
            __variant_ops<_Types...>::__copy_assign[__index](this,__other);
        }
        else{
            __destroy_self();
            __index=__copy_construct(__other);
        }
        return *this;
    }
    variant& operator=(variant&& __other){
        if(__other.__index==-1){
            __destroy_self();
        }
        else if(__other.__index==__index){
            __variant_ops<_Types...>::__move_assign[__index](this,__other);
        }
        else{
            __destroy_self();
            __index=__move_construct(__other);
        }
        return *this;
    }

    template<typename _Type,typename ... _Args>
    void emplace(_Args&& ... __args){
        __destroy_self();
        __index=__emplace_construct<_Type>(std::forward<_Args>(__args)...);
    }
    
    template<ptrdiff_t _Index,typename ... _Args>
    void emplace(_Args&& ... __args){
        __destroy_self();
        __emplace_construct<typename __indexed_type<_Index,_Types...>::__type>(
            std::forward<_Args>(__args)...);
        __index=_Index;
    }
    
    constexpr bool empty() const noexcept{
        return __index==-1;
    }
    constexpr ptrdiff_t index() const noexcept{
        return __index;
    }

    void swap(variant& __other){
        if(__other.__index==__index){
            if(__index!=-1)
                __variant_ops<_Types...>::__swap[__index](this,__other);
        }
        else{
            std::swap(*this,__other);
        }
    }
};

template<typename ... _Types>
struct __variant_accessor<-1,_Types...>{
    static constexpr empty_t& get(variant<_Types...>& __v){
        return static_cast<empty_t&>(__v);
    }
    static constexpr empty_t const& get(variant<_Types...> const& __v){
        return static_cast<empty_t const&>(__v);
    }
};

template<ptrdiff_t _Index,typename ... _Types>
struct __variant_accessor{
    typedef typename __indexed_type<_Index,_Types...>::__type __type;
    static constexpr __type& get(variant<_Types...>& __v){
        return __stored_type<__type>::__get(&__v.__storage);
    }
    static constexpr __type const& get(variant<_Types...> const& __v){
        return __stored_type<__type>::__get(&__v.__storage);
    }
};

template<typename _Type,typename ... _Types>
constexpr _Type& get(variant<_Types...>& __v){
    return get<__type_index<_Type,_Types...>::__value>(__v);
}

template<typename _Type,typename ... _Types>
constexpr _Type const& get(variant<_Types...> const& __v){
    return get<__type_index<_Type,_Types...>::__value>(__v);
}

template<ptrdiff_t _Index,typename ... _Types>
constexpr typename __indexed_type<_Index,_Types...>::__type const& get(
    variant<_Types...> const& __v){
    return *((_Index!=__v.index())?throw bad_variant_access("Bad variant index in get"):
        &__variant_accessor<_Index,_Types...>::get(__v));
}

template<ptrdiff_t _Index,typename ... _Types>
constexpr typename __indexed_type<_Index,_Types...>::__type& get(variant<_Types...>& __v){
    return *((_Index!=__v.index())?throw bad_variant_access("Bad variant index in get"):
        &__variant_accessor<_Index,_Types...>::get(__v));
}

template<typename _Type,typename ... _Types>
constexpr bool holds_alternative(variant<_Types...> const& __v) noexcept{
    return __v.index()==__type_index<_Type,_Types...>::__value;
}

template<typename _Visitor,typename ... _Types>
struct __visitor_table{
    typedef variant<_Types...> __variant_type;
    typedef void(*__func_type)(_Visitor&,__variant_type&);

    template<typename _Type>
    static void __trampoline_func(_Visitor& __visitor,__variant_type& __v){
        __visitor(get<_Type>(__v));
    }

    static constexpr __func_type __trampoline[sizeof...(_Types)]={
        &__trampoline_func<_Types>...
    };
};

template<typename _Visitor,typename ... _Types>
constexpr typename __visitor_table<_Visitor,_Types...>::__func_type __visitor_table<_Visitor,_Types...>::__trampoline[sizeof...(_Types)];

template<typename _Visitor,typename ... _Types>
void visit(_Visitor& __visitor,variant<_Types...>& __v){
    if(__v.empty())
        return;
    __visitor_table<_Visitor,_Types...>::__trampoline[__v.index()](__visitor,__v);
}

template<typename ... _Types>
bool operator==(variant<_Types...> const& __lhs,variant<_Types...> const& __rhs){
    return (__lhs.index()==__rhs.index()) &&
        ((__lhs.index()==-1) ||
         __variant_ops<_Types...>::__equality_compare[__lhs.index()](__lhs,__rhs));
}

template<typename ... _Types>
bool operator!=(variant<_Types...> const& __lhs,variant<_Types...> const& __rhs){
    return !(__lhs==__rhs);
}

template<typename ... _Types>
bool operator<(variant<_Types...> const& __lhs,variant<_Types...> const& __rhs){
    return (__lhs.index()<__rhs.index()) ||
        ((__lhs.index()==__rhs.index()) &&
         ((__lhs.index()!=-1) &&
         __variant_ops<_Types...>::__less_than_compare[__lhs.index()](__lhs,__rhs)));
}

template<typename ... _Types>
bool operator>(variant<_Types...> const& __lhs,variant<_Types...> const& __rhs){
    return __rhs<__lhs;
}

template<typename ... _Types>
bool operator<=(variant<_Types...> const& __lhs,variant<_Types...> const& __rhs){
    return !(__rhs<__lhs);
}

template<typename ... _Types>
bool operator>=(variant<_Types...> const& __lhs,variant<_Types...> const& __rhs){
    return !(__lhs>__rhs);
}

}
}

#endif
