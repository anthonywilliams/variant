// -*- C++ -*-
#ifndef _JSS_EXPERIMENTAL_VARIANT_HEADER
#define _JSS_EXPERIMENTAL_VARIANT_HEADER
#include <stddef.h>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <new>

namespace std{
namespace experimental{

struct empty_t{};

class bad_variant_access: public std::logic_error{
public:
    explicit bad_variant_access(const std::string& what_arg):
        std::logic_error(what_arg)
    {}
    explicit bad_variant_access(const char* what_arg):
        std::logic_error(what_arg)
    {}
};

template<ptrdiff_t _Offset,typename _Type,typename _Head,typename ... _Rest>
struct __type_index_helper{
    static constexpr ptrdiff_t __value=
        __type_index_helper<_Offset+1,_Head,_Rest...>::__value;
};

template<ptrdiff_t _Offset,typename _Type,typename ... _Rest>
struct __type_index_helper<_Offset,_Type,_Type,_Rest...>{
    static constexpr ptrdiff_t __value=_Offset;
};

template<typename _Type,typename ... _Types>
struct __type_index{
    static constexpr ptrdiff_t __value=
        __type_index_helper<0,_Type,_Types...>::__value;
};

template<typename ... _Types>
struct __type_index<empty_t,_Types...>{
    static constexpr ptrdiff_t __value=-1;
};



template<ptrdiff_t _Index,typename ... _Types>
struct __indexed_type;

template<typename ... _Types>
struct __indexed_type<-1,_Types...>{
    typedef empty_t __type;
};

template<typename _Head,typename ... _Rest>
struct __indexed_type<-1,_Head,_Rest...>{
    typedef empty_t __type;
};

template<typename _Head,typename ... _Rest>
struct __indexed_type<0,_Head,_Rest...>{
    typedef _Head __type;
};

template<ptrdiff_t _Index,typename _Head,typename ... _Rest>
struct __indexed_type<_Index,_Head,_Rest...>{
    typedef typename __indexed_type<_Index-1,_Rest...>::__type __type;
};

template<typename ... _Types>
class variant;

template<typename _Type,typename ... _Types>
_Type& get(variant<_Types...>&);

template<ptrdiff_t _Index,typename ... _Types>
typename __indexed_type<_Index,_Types...>::__type& get(variant<_Types...>&);

template<ptrdiff_t _Index,typename ... _Types>
struct __variant_accessor;

template<size_t __count>
struct __descriminator_type{
    typedef signed char __type;
};

template<typename ... _Types>
struct __max_size;

template<>
struct __max_size<>{
    static constexpr size_t __value=0;
};

template<typename _Type>
struct __max_size<_Type>{
    static constexpr size_t __value=sizeof(_Type);
};

template<typename _Head,typename ... _Rest>
struct __max_size<_Head,_Rest...>{
    static constexpr size_t __rest_max=__max_size<_Rest...>::__value;
    static constexpr size_t __value=
        (__rest_max>sizeof(_Head))?__rest_max:sizeof(_Head);
};

template<typename ... _Types>
struct __max_align;

template<>
struct __max_align<>{
    static constexpr size_t __value=0;
};

template<typename _Type>
struct __max_align<_Type>{
    static constexpr size_t __value=alignof(_Type);
};

template<typename _Head,typename ... _Rest>
struct __max_align<_Head,_Rest...>{
    static constexpr size_t __rest_max=__max_align<_Rest...>::__value;
    static constexpr size_t __value=
        (__rest_max>alignof(_Head))?__rest_max:alignof(_Head);
};

template<typename ... _Types>
class variant: private empty_t{
    template<ptrdiff_t _Index,typename ... _Types2>
    friend struct __variant_accessor;

    typename std::aligned_storage<
        __max_size<_Types...>::__value,
        __max_align<_Types...>::__value>::type __storage;
    typename __descriminator_type<sizeof ... (_Types)>::__type __index;

    template<typename _Type>
    void __construct(_Type&& __x){
        new (static_cast<void*>(&__storage))
            typename std::remove_reference<_Type>::type
            (std::forward<_Type>(__x));
    }
    
public:
    constexpr variant() noexcept:
        __index(-1)
    {}

    template<typename _Type>
    constexpr variant(_Type&& __x):
        __index((__construct(__x),__type_index<_Type,_Types...>::__value))
    {}
    
    constexpr bool empty() const noexcept{
        return true;
    }
    constexpr ptrdiff_t index() const noexcept{
        return __index;
    }
};

template<typename ... _Types>
struct __variant_accessor<-1,_Types...>{
    static empty_t& get(variant<_Types...>& __v){
        return static_cast<empty_t&>(__v);
    }
};

template<ptrdiff_t _Index,typename ... _Types>
struct __variant_accessor{
    typedef typename __indexed_type<_Index,_Types...>::__type __type;
    static __type* get_ptr(variant<_Types...>& __v){
        return static_cast<__type*>(static_cast<void*>(&__v.__storage));
    }
    static __type& get(variant<_Types...>& __v){
        return *get_ptr(__v);
    }
};

template<typename _Type,typename ... _Types>
_Type& get(variant<_Types...>& __v){
    return get<__type_index<_Type,_Types...>::__value>(__v);
}

template<ptrdiff_t _Index,typename ... _Types>
typename __indexed_type<_Index,_Types...>::__type& get(variant<_Types...>& __v){
    if(_Index!=__v.index())
        throw bad_variant_access("Bad variant index in get");
    return __variant_accessor<_Index,_Types...>::get(__v);
}

}
}

#endif
