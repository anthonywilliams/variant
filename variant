// -*- C++ -*-
// Copyright (c) 2015, Just Software Solutions Ltd
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or
// without modification, are permitted provided that the
// following conditions are met:
//
// 1. Redistributions of source code must retain the above
// copyright notice, this list of conditions and the following
// disclaimer.
//
// 2. Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following
// disclaimer in the documentation and/or other materials
// provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of
// its contributors may be used to endorse or promote products
// derived from this software without specific prior written
// permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
// CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#ifndef _JSS_EXPERIMENTAL_VARIANT_HEADER
#define _JSS_EXPERIMENTAL_VARIANT_HEADER
#include <stddef.h>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <new>
#include <utility>

namespace std{
namespace experimental{

struct empty_t{};

template<typename _Type>
struct emplaced_type_t{};

template<ptrdiff_t _Index>
struct emplaced_index_t{};

class bad_variant_access: public std::logic_error{
public:
    explicit bad_variant_access(const std::string& what_arg):
        std::logic_error(what_arg)
    {}
    explicit bad_variant_access(const char* what_arg):
        std::logic_error(what_arg)
    {}
};

template<ptrdiff_t _Offset,typename _Type,typename ... _Types>
struct __type_index_helper;

template<ptrdiff_t _Offset,typename _Type,typename _Head,typename ... _Rest>
struct __type_index_helper<_Offset,_Type,_Head,_Rest...>{
    static constexpr ptrdiff_t __value=
        __type_index_helper<_Offset+1,_Type,_Rest...>::__value;
};

template<ptrdiff_t _Offset,typename _Type,typename ... _Rest>
struct __type_index_helper<_Offset,_Type,_Type,_Rest...>{
    static constexpr ptrdiff_t __value=_Offset;
};

template<typename _Type,typename ... _Types>
struct __type_index{
    static constexpr ptrdiff_t __value=
        __type_index_helper<0,_Type,_Types...>::__value;
};

template<typename ... _Types>
struct __type_index<empty_t,_Types...>{
    static constexpr ptrdiff_t __value=-1;
};



template<ptrdiff_t _Index,typename ... _Types>
struct __indexed_type;

template<typename ... _Types>
struct __indexed_type<-1,_Types...>{
    typedef empty_t __type;
};

template<typename _Head,typename ... _Rest>
struct __indexed_type<-1,_Head,_Rest...>{
    typedef empty_t __type;
};

template<typename _Head,typename ... _Rest>
struct __indexed_type<0,_Head,_Rest...>{
    typedef _Head __type;
};

template<ptrdiff_t _Index,typename _Head,typename ... _Rest>
struct __indexed_type<_Index,_Head,_Rest...>{
    typedef typename __indexed_type<_Index-1,_Rest...>::__type __type;
};

template<ptrdiff_t _Index,typename ..._Types>
struct __next_index{
    static constexpr ptrdiff_t __value=
        (_Index>=ptrdiff_t(sizeof...(_Types)-1))?-1:_Index+1;
};

template<typename ... _Types>
class variant;

template<typename _Type,typename ... _Types>
_Type& get(variant<_Types...>&);

template<typename _Type,typename ... _Types>
_Type const& get(variant<_Types...> const&);

template<ptrdiff_t _Index,typename ... _Types>
typename __indexed_type<_Index,_Types...>::__type& get(variant<_Types...>&);

template<ptrdiff_t _Index,typename ... _Types>
typename __indexed_type<_Index,_Types...>::__type const& get(
    variant<_Types...> const&);

template<ptrdiff_t _Index,typename ... _Types>
struct __variant_accessor;

template<size_t __count>
struct __descriminator_type{
    typedef signed char __type;
};

template<typename _Type>
struct __stored_type{
    typedef _Type __type;
    template<typename ... _Args>
    static constexpr void __construct(void* __storage,_Args&& ... __args){
        new (__storage) _Type(std::forward<_Args>(__args)...);
    }

    static constexpr _Type& __get(void* __storage){
        return *static_cast<__type*>(__storage);
    }

    static constexpr const _Type& __get(const void* __storage){
        return *static_cast<const __type*>(__storage);
    }
    
    static void __destroy(void* __storage){
        static_cast<__type*>(__storage)->~__type();
    }
};

template<typename _Type>
struct __stored_type<_Type&>{
    typedef _Type* __type;

    template<typename  _Arg>
    static constexpr void __construct(void* __storage,_Arg& __arg){
        new (__storage) __type(&__arg);
    }

    static constexpr _Type& __get(void* __storage){
        return **static_cast<__type*>(__storage);
    }

    static constexpr const _Type& __get(const void* __storage){
        return **static_cast<const __type*>(__storage);
    }
    
    static void __destroy(void* __storage){
        static_cast<__type*>(__storage)->~__type();
    }
};

template<typename ... _Types>
struct __max_size;

template<>
struct __max_size<>{
    static constexpr size_t __value=0;
};

template<typename _Type>
struct __max_size<_Type>{
    static constexpr size_t __value=
        sizeof(typename __stored_type<_Type>::__type);
};

template<typename _Head,typename ... _Rest>
struct __max_size<_Head,_Rest...>{
    static constexpr size_t __this_size=
        sizeof(typename __stored_type<_Head>::__type);
    static constexpr size_t __rest_max=__max_size<_Rest...>::__value;
    static constexpr size_t __value=
        (__rest_max>__this_size)?__rest_max:__this_size;
};

template<typename ... _Types>
struct __max_align;

template<>
struct __max_align<>{
    static constexpr size_t __value=0;
};

template<typename _Type>
struct __max_align<_Type>{
    static constexpr size_t __value=
        alignof(typename __stored_type<_Type>::__type);
};

template<typename _Head,typename ... _Rest>
struct __max_align<_Head,_Rest...>{
    static constexpr size_t __this_align=
        alignof(typename __stored_type<_Head>::__type);
    static constexpr size_t __rest_max=__max_align<_Rest...>::__value;
    static constexpr size_t __value=
        (__rest_max>__this_align)?__rest_max:__this_align;
};

template<typename ... _Types>
struct __variant_ops{
    typedef variant<_Types...> __variant_type;
    typedef void(*__copy_func_type)(__variant_type*,__variant_type const&);
    typedef void(*__move_func_type)(__variant_type*,__variant_type&);
    typedef void(*__unary_func_type)(__variant_type*);
    typedef bool(*__compare_func_type)(__variant_type const&,__variant_type const&);

    template<typename _Type>
    static void __copy_construct_func(
        __variant_type* __self,__variant_type const& __other){
        __stored_type<_Type>::__construct(
            &__self->__storage,
            __stored_type<_Type>::__get(&__other.__storage));
    }

    template<typename _Type>
    static void __move_construct_func(
        __variant_type* __self,__variant_type& __other){
        __stored_type<_Type>::__construct(
            &__self->__storage,
            std::move(__stored_type<_Type>::__get(&__other.__storage)));
    }
    
    template<typename _Type>
    static void __copy_assign_func(
        __variant_type* __self,__variant_type const& __other){
        get<_Type>(*__self)=get<_Type>(__other);
    }

    template<typename _Type>
    static void __move_assign_func(
        __variant_type* __self,__variant_type& __other){
        get<_Type>(*__self)=std::move(get<_Type>(__other));
        __other.__destroy_self();
    }

    template<typename _Type>
    static void __destroy_func(__variant_type* __self){
        __stored_type<_Type>::__destroy(&__self->__storage);
    }
    
    template<typename _Type>
    static void __swap_func(
        __variant_type* __self,__variant_type& __other){
        swap(get<_Type>(*__self),get<_Type>(__other));
    }

    template<typename _Type>
    static bool __equality_compare_func(
        __variant_type const& __lhs,__variant_type const& __rhs){
        return get<_Type>(__lhs)==get<_Type>(__rhs);
    }

    template<typename _Type>
    static bool __less_than_compare_func(
        __variant_type const& __lhs,__variant_type const& __rhs){
        return get<_Type>(__lhs)<get<_Type>(__rhs);
    }
    
    static constexpr __copy_func_type __copy_construct[sizeof...(_Types)]={
        &__copy_construct_func<_Types>...
    };
    static constexpr __move_func_type __move_construct[sizeof...(_Types)]={
        &__move_construct_func<_Types>...
    };
    static constexpr __copy_func_type __copy_assign[sizeof...(_Types)]={
        &__copy_assign_func<_Types>...
    };
    static constexpr __move_func_type __move_assign[sizeof...(_Types)]={
        &__move_assign_func<_Types>...
    };
    static constexpr __move_func_type __swap[sizeof...(_Types)]={
        &__swap_func<_Types>...
    };
    static constexpr __unary_func_type __destroy[sizeof...(_Types)]={
        &__destroy_func<_Types>...
    };
    static constexpr __compare_func_type __equality_compare[sizeof...(_Types)]={
        &__equality_compare_func<_Types>...
    };
    static constexpr __compare_func_type __less_than_compare[sizeof...(_Types)]={
        &__less_than_compare_func<_Types>...
    };
};

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__copy_func_type
__variant_ops<_Types...>::__copy_construct[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__move_func_type
__variant_ops<_Types...>::__move_construct[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__copy_func_type
__variant_ops<_Types...>::__copy_assign[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__move_func_type
__variant_ops<_Types...>::__move_assign[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__move_func_type
__variant_ops<_Types...>::__swap[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__unary_func_type
__variant_ops<_Types...>::__destroy[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__compare_func_type
__variant_ops<_Types...>::__equality_compare[sizeof...(_Types)];

template<typename ... _Types>
constexpr typename __variant_ops<_Types...>::__compare_func_type
__variant_ops<_Types...>::__less_than_compare[sizeof...(_Types)];

template<typename ... _Types>
class variant: private empty_t{
    friend struct __variant_ops<_Types...>;
    
    template<ptrdiff_t _Index,typename ... _Types2>
    friend struct __variant_accessor;

    typename std::aligned_storage<
        __max_size<_Types...>::__value,
        __max_align<_Types...>::__value>::type __storage;
    typename __descriminator_type<sizeof ... (_Types)>::__type __index;

    template<typename _Type,typename ... _Args>
    ptrdiff_t __emplace_construct(_Args&& ... __args){
        __stored_type<_Type>::__construct(
            &__storage,std::forward<_Args>(__args)...);
        return  __type_index<_Type,_Types...>::__value;
    }
    
    void __destroy_self(){
        if(__index==-1)
            return;
        ptrdiff_t const __old_index=__index;
        __index=-1;
        __variant_ops<_Types...>::__destroy[__old_index](this);
    }
    
    ptrdiff_t __move_construct(variant& __other){
        ptrdiff_t const __other_index=__other.index();
        if(__other_index==-1)
            return -1;
        __variant_ops<_Types...>::__move_construct[__other_index](this,__other);
        __other.__destroy_self();
        return __other_index;
    }

    ptrdiff_t __copy_construct(variant const& __other){
        ptrdiff_t const __other_index=__other.index();
        if(__other_index==-1)
            return -1;
        __variant_ops<_Types...>::__copy_construct[__other_index](this,__other);
        return __other_index;
    }
    
public:
    constexpr variant() noexcept:
        __index(-1)
    {}

    constexpr variant(variant&& __other):
        __index(__move_construct(__other))
    {}

    constexpr variant(variant& __other):
        __index(__copy_construct(__other))
    {}

    constexpr variant(variant const& __other):
        __index(__copy_construct(__other))
    {}

    template<typename _Type,typename ... _Args>
    explicit constexpr variant(emplaced_type_t<_Type>,_Args&& ... __args):
        __index(__emplace_construct<_Type>(std::forward<_Args>(__args)...))
    {}

    template<ptrdiff_t _Index,typename ... _Args>
    explicit constexpr variant(emplaced_index_t<_Index>,_Args&& ... __args):
        __index(
            (__emplace_construct<
             typename __indexed_type<_Index,_Types...>::__type>(
                 std::forward<_Args>(__args)...),
             _Index))
    {}
    
    ~variant(){
        __destroy_self();
    }
    
    template<typename _Type>
    constexpr variant(_Type&& __x):
        __index(__emplace_construct<typename std::remove_const<
                typename std::remove_reference<_Type>::type>::type>(
                    std::forward<_Type>(__x)))
    {}

    template<typename _Type>
    variant& operator=(_Type&& __x){
        typedef typename std::remove_const<
            typename std::remove_reference<_Type>::type>::type __type;
        constexpr ptrdiff_t _Index=__type_index<__type,_Types...>::__value;
        if(_Index==__index){
            get<_Index>(*this)=std::forward<_Type>(__x);
        }
        else{
            __destroy_self();
            __stored_type<__type>::__construct(&__storage,std::forward<_Type>(__x));
            __index=_Index;
        }
        return *this;
    }

    variant& operator=(variant const& __other){
        if(__other.__index==-1){
            __destroy_self();
        }
        else if(__other.__index==__index){
            __variant_ops<_Types...>::__copy_assign[__index](this,__other);
        }
        else{
            __destroy_self();
            __index=__copy_construct(__other);
        }
        return *this;
    }
    variant& operator=(variant& __other){
        if(__other.__index==-1){
            __destroy_self();
        }
        else if(__other.__index==__index){
            __variant_ops<_Types...>::__copy_assign[__index](this,__other);
        }
        else{
            __destroy_self();
            __index=__copy_construct(__other);
        }
        return *this;
    }
    variant& operator=(variant&& __other){
        if(__other.__index==-1){
            __destroy_self();
        }
        else if(__other.__index==__index){
            __variant_ops<_Types...>::__move_assign[__index](this,__other);
        }
        else{
            __destroy_self();
            __index=__move_construct(__other);
        }
        return *this;
    }

    template<typename _Type,typename ... _Args>
    void emplace(_Args&& ... __args){
        __destroy_self();
        __index=__emplace_construct<_Type>(std::forward<_Args>(__args)...);
    }
    
    template<ptrdiff_t _Index,typename ... _Args>
    void emplace(_Args&& ... __args){
        __destroy_self();
        __emplace_construct<typename __indexed_type<_Index,_Types...>::__type>(
            std::forward<_Args>(__args)...);
        __index=_Index;
    }
    
    constexpr bool empty() const noexcept{
        return __index==-1;
    }
    constexpr ptrdiff_t index() const noexcept{
        return __index;
    }

    void swap(variant& __other){
        if(__other.__index==__index){
            if(__index!=-1)
                __variant_ops<_Types...>::__swap[__index](this,__other);
        }
        else{
            std::swap(*this,__other);
        }
    }
};

template<typename ... _Types>
struct __variant_accessor<-1,_Types...>{
    static constexpr empty_t& get(variant<_Types...>& __v){
        return static_cast<empty_t&>(__v);
    }
    static constexpr empty_t const& get(variant<_Types...> const& __v){
        return static_cast<empty_t const&>(__v);
    }
};

template<ptrdiff_t _Index,typename ... _Types>
struct __variant_accessor{
    typedef typename __indexed_type<_Index,_Types...>::__type __type;
    static constexpr __type& get(variant<_Types...>& __v){
        return __stored_type<__type>::__get(&__v.__storage);
    }
    static constexpr __type const& get(variant<_Types...> const& __v){
        return __stored_type<__type>::__get(&__v.__storage);
    }
};

template<typename _Type,typename ... _Types>
_Type& get(variant<_Types...>& __v){
    return get<__type_index<_Type,_Types...>::__value>(__v);
}

template<typename _Type,typename ... _Types>
_Type const& get(variant<_Types...> const& __v){
    return get<__type_index<_Type,_Types...>::__value>(__v);
}

template<ptrdiff_t _Index,typename ... _Types>
typename __indexed_type<_Index,_Types...>::__type const& get(
    variant<_Types...> const& __v){
    if(_Index!=__v.index())
        throw bad_variant_access("Bad variant index in get");
    return __variant_accessor<_Index,_Types...>::get(__v);
}

template<ptrdiff_t _Index,typename ... _Types>
typename __indexed_type<_Index,_Types...>::__type& get(variant<_Types...>& __v){
    if(_Index!=__v.index())
        throw bad_variant_access("Bad variant index in get");
    return __variant_accessor<_Index,_Types...>::get(__v);
}

template<typename _Type,typename ... _Types>
constexpr bool holds_alternative(variant<_Types...> const& __v) noexcept{
    return __v.index()==__type_index<_Type,_Types...>::__value;
}

template<typename _Visitor,typename ... _Types>
struct __visitor_table{
    typedef variant<_Types...> __variant_type;
    typedef void(*__func_type)(_Visitor&,__variant_type&);

    template<typename _Type>
    static void __trampoline_func(_Visitor& __visitor,__variant_type& __v){
        __visitor(get<_Type>(__v));
    }

    static constexpr __func_type __trampoline[sizeof...(_Types)]={
        &__trampoline_func<_Types>...
    };
};

template<typename _Visitor,typename ... _Types>
constexpr typename __visitor_table<_Visitor,_Types...>::__func_type __visitor_table<_Visitor,_Types...>::__trampoline[sizeof...(_Types)];

template<typename _Visitor,typename ... _Types>
void visit(_Visitor& __visitor,variant<_Types...>& __v){
    if(__v.empty())
        return;
    __visitor_table<_Visitor,_Types...>::__trampoline[__v.index()](__visitor,__v);
}

template<typename ... _Types>
bool operator==(variant<_Types...> const& __lhs,variant<_Types...> const& __rhs){
    return (__lhs.index()==__rhs.index()) &&
        ((__lhs.index()==-1) ||
         __variant_ops<_Types...>::__equality_compare[__lhs.index()](__lhs,__rhs));
}

template<typename ... _Types>
bool operator!=(variant<_Types...> const& __lhs,variant<_Types...> const& __rhs){
    return !(__lhs==__rhs);
}

template<typename ... _Types>
bool operator<(variant<_Types...> const& __lhs,variant<_Types...> const& __rhs){
    return (__lhs.index()<__rhs.index()) ||
        ((__lhs.index()==__rhs.index()) &&
         ((__lhs.index()!=-1) &&
         __variant_ops<_Types...>::__less_than_compare[__lhs.index()](__lhs,__rhs)));
}

template<typename ... _Types>
bool operator>(variant<_Types...> const& __lhs,variant<_Types...> const& __rhs){
    return __rhs<__lhs;
}

template<typename ... _Types>
bool operator<=(variant<_Types...> const& __lhs,variant<_Types...> const& __rhs){
    return !(__rhs<__lhs);
}

template<typename ... _Types>
bool operator>=(variant<_Types...> const& __lhs,variant<_Types...> const& __rhs){
    return !(__lhs>__rhs);
}

}
}

#endif
