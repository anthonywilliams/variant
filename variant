// -*- C++ -*-
#ifndef _JSS_EXPERIMENTAL_VARIANT_HEADER
#define _JSS_EXPERIMENTAL_VARIANT_HEADER
#include <stddef.h>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <new>

namespace std{
namespace experimental{

struct empty_t{};

class bad_variant_access: public std::logic_error{
public:
    explicit bad_variant_access(const std::string& what_arg):
        std::logic_error(what_arg)
    {}
    explicit bad_variant_access(const char* what_arg):
        std::logic_error(what_arg)
    {}
};

template<ptrdiff_t _Offset,typename _Type,typename ... _Types>
struct __type_index_helper;

template<ptrdiff_t _Offset,typename _Type,typename _Head,typename ... _Rest>
struct __type_index_helper<_Offset,_Type,_Head,_Rest...>{
    static constexpr ptrdiff_t __value=
        __type_index_helper<_Offset+1,_Type,_Rest...>::__value;
};

template<ptrdiff_t _Offset,typename _Type,typename ... _Rest>
struct __type_index_helper<_Offset,_Type,_Type,_Rest...>{
    static constexpr ptrdiff_t __value=_Offset;
};

template<typename _Type,typename ... _Types>
struct __type_index{
    static constexpr ptrdiff_t __value=
        __type_index_helper<0,_Type,_Types...>::__value;
};

template<typename ... _Types>
struct __type_index<empty_t,_Types...>{
    static constexpr ptrdiff_t __value=-1;
};



template<ptrdiff_t _Index,typename ... _Types>
struct __indexed_type;

template<typename ... _Types>
struct __indexed_type<-1,_Types...>{
    typedef empty_t __type;
};

template<typename _Head,typename ... _Rest>
struct __indexed_type<-1,_Head,_Rest...>{
    typedef empty_t __type;
};

template<typename _Head,typename ... _Rest>
struct __indexed_type<0,_Head,_Rest...>{
    typedef _Head __type;
};

template<ptrdiff_t _Index,typename _Head,typename ... _Rest>
struct __indexed_type<_Index,_Head,_Rest...>{
    typedef typename __indexed_type<_Index-1,_Rest...>::__type __type;
};

template<ptrdiff_t _Index,typename ..._Types>
struct __next_index{
    static constexpr ptrdiff_t __value=
        (_Index>=ptrdiff_t(sizeof...(_Types)-1))?-1:_Index+1;
};

template<typename ... _Types>
class variant;

template<typename _Type,typename ... _Types>
_Type& get(variant<_Types...>&);

template<ptrdiff_t _Index,typename ... _Types>
typename __indexed_type<_Index,_Types...>::__type& get(variant<_Types...>&);

template<ptrdiff_t _Index,typename ... _Types>
struct __variant_accessor;

template<size_t __count>
struct __descriminator_type{
    typedef signed char __type;
};

template<typename ... _Types>
struct __max_size;

template<>
struct __max_size<>{
    static constexpr size_t __value=0;
};

template<typename _Type>
struct __max_size<_Type>{
    static constexpr size_t __value=sizeof(_Type);
};

template<typename _Head,typename ... _Rest>
struct __max_size<_Head,_Rest...>{
    static constexpr size_t __rest_max=__max_size<_Rest...>::__value;
    static constexpr size_t __value=
        (__rest_max>sizeof(_Head))?__rest_max:sizeof(_Head);
};

template<typename ... _Types>
struct __max_align;

template<>
struct __max_align<>{
    static constexpr size_t __value=0;
};

template<typename _Type>
struct __max_align<_Type>{
    static constexpr size_t __value=alignof(_Type);
};

template<typename _Head,typename ... _Rest>
struct __max_align<_Head,_Rest...>{
    static constexpr size_t __rest_max=__max_align<_Rest...>::__value;
    static constexpr size_t __value=
        (__rest_max>alignof(_Head))?__rest_max:alignof(_Head);
};

template<ptrdiff_t _Index,typename ... _Types>
struct __variant_constructor;

template<typename ... _Types>
class variant: private empty_t{
    template<ptrdiff_t _Index,typename ... _Types2>
    friend struct __variant_accessor;
    template<ptrdiff_t _Index,typename ... _Types2>
    friend struct __variant_constructor;

    typename std::aligned_storage<
        __max_size<_Types...>::__value,
        __max_align<_Types...>::__value>::type __storage;
    typename __descriminator_type<sizeof ... (_Types)>::__type __index;

    template<typename _Type>
    void __construct(_Type&& __x){
        new (static_cast<void*>(&__storage))
            typename std::remove_reference<_Type>::type
            (std::forward<_Type>(__x));
    }

    template<typename _Type>
    void __destroy(){
        __index=-1;
        static_cast<_Type*>(static_cast<void*>(&__storage))->~_Type();
    }

    ptrdiff_t __move_construct(variant& __other){
        ptrdiff_t const __other_index=__other.index();
        if(__other_index==-1)
            return -1;
        __variant_constructor<0,_Types...>::__move_construct(this,__other);
        __variant_constructor<0,_Types...>::__destroy(&__other);
        return __other_index;
    }
    
public:
    constexpr variant() noexcept:
        __index(-1)
    {}

    constexpr variant(variant&& __other):
        __index(__move_construct(__other))
    {}

    template<typename _Type>
    constexpr variant(_Type&& __x):
        __index((__construct(__x),__type_index<_Type,_Types...>::__value))
    {}
    
    constexpr bool empty() const noexcept{
        return true;
    }
    constexpr ptrdiff_t index() const noexcept{
        return __index;
    }
};

template<ptrdiff_t _Index,typename ... _Types>
struct __variant_constructor{
    static constexpr void __move_construct(
        variant<_Types...>* __self,
        variant<_Types...>& __other){
        if(_Index==__other.index()){
            __self->template __construct<
                typename __indexed_type<_Index,_Types...>::__type>(
                std::move(get<_Index>(__other)));
        }
        else{
            __variant_constructor<
                __next_index<_Index,_Types...>::__value,_Types...>::
                __move_construct(__self,__other);
        }
    }
    static constexpr void __destroy(
        variant<_Types...>* __self){
        if(_Index==__self->__index){
            __self->template __destroy<
                typename __indexed_type<_Index,_Types...>::__type>();
        }
        else{
            __variant_constructor<
                __next_index<_Index,_Types...>::__value,_Types...>::__destroy(
                    __self);
        }
    }
};


template<typename ... _Types>
struct __variant_accessor<-1,_Types...>{
    static constexpr empty_t& get(variant<_Types...>& __v){
        return static_cast<empty_t&>(__v);
    }
};

template<ptrdiff_t _Index,typename ... _Types>
struct __variant_accessor{
    typedef typename __indexed_type<_Index,_Types...>::__type __type;
    static constexpr __type* get_ptr(variant<_Types...>& __v){
        return static_cast<__type*>(static_cast<void*>(&__v.__storage));
    }
    static constexpr __type& get(variant<_Types...>& __v){
        return *get_ptr(__v);
    }
};

template<typename _Type,typename ... _Types>
_Type& get(variant<_Types...>& __v){
    return get<__type_index<_Type,_Types...>::__value>(__v);
}

template<ptrdiff_t _Index,typename ... _Types>
typename __indexed_type<_Index,_Types...>::__type& get(variant<_Types...>& __v){
    if(_Index!=__v.index())
        throw bad_variant_access("Bad variant index in get");
    return __variant_accessor<_Index,_Types...>::get(__v);
}

}
}

#endif
