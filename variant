// -*- C++ -*-
#ifndef _JSS_EXPERIMENTAL_VARIANT_HEADER
#define _JSS_EXPERIMENTAL_VARIANT_HEADER
#include <stddef.h>
#include <stdexcept>
#include <string>

namespace std{
namespace experimental{

struct empty_t{};

class bad_variant_access: public std::logic_error{
public:
    explicit bad_variant_access(const std::string& what_arg):
        std::logic_error(what_arg)
    {}
    explicit bad_variant_access(const char* what_arg):
        std::logic_error(what_arg)
    {}
};

template<ptrdiff_t _Offset,typename _Type,typename _Head,typename ... _Rest>
struct __type_index_helper{
    static constexpr ptrdiff_t __value=
        __type_index_helper<_Offset+1,_Head,_Rest...>::__value;
};

template<ptrdiff_t _Offset,typename _Type,typename ... _Rest>
struct __type_index_helper<_Offset,_Type,_Type,_Rest...>{
    static constexpr ptrdiff_t __value=_Offset;
};

template<typename _Type,typename ... _Types>
struct __type_index{
    static constexpr ptrdiff_t __value=
        __type_index_helper<0,_Type,_Types...>::__value;
};

template<typename ... _Types>
struct __type_index<empty_t,_Types...>{
    static constexpr ptrdiff_t __value=-1;
};



template<ptrdiff_t _Index,typename ... _Types>
struct __indexed_type;

template<typename ... _Types>
struct __indexed_type<-1,_Types...>{
    typedef empty_t __type;
};

template<typename _Head,typename ... _Rest>
struct __indexed_type<-1,_Head,_Rest...>{
    typedef empty_t __type;
};

template<typename _Head,typename ... _Rest>
struct __indexed_type<0,_Head,_Rest...>{
    typedef _Head __type;
};

template<ptrdiff_t _Index,typename _Head,typename ... _Rest>
struct __indexed_type<_Index,_Head,_Rest...>{
    typedef typename __indexed_type<_Index-1,_Rest...>::__type __type;
};

template<typename ... _Types>
class variant;

template<typename _Type,typename ... _Types>
_Type& get(variant<_Types...>&);

template<ptrdiff_t _Index,typename ... _Types>
typename __indexed_type<_Index,_Types...>::__type& get(variant<_Types...>&);

template<ptrdiff_t _Index,typename ... _Types>
struct __variant_accessor;

template<size_t __count>
struct __descriminator_type{
    typedef signed char __type;
};

template<typename ... _Types>
class variant: private empty_t{
    template<ptrdiff_t _Index,typename ... _Types2>
    friend struct __variant_accessor;

    typename __descriminator_type<sizeof ... (_Types)>::__type __index;
    
public:
    constexpr variant() noexcept:
        __index(-1)
    {}

    template<typename _Type>
    constexpr variant(_Type&& __x):
        __index(__type_index<_Type,_Types...>::__value)
    {}
    
    constexpr bool empty() const noexcept{
        return true;
    }
    constexpr ptrdiff_t index() const noexcept{
        return __index;
    }
};

template<typename ... _Types>
struct __variant_accessor<-1,_Types...>{
    static empty_t& get(variant<_Types...>& __v){
        return static_cast<empty_t&>(__v);
    }
};

template<typename _Type,typename ... _Types>
_Type& get(variant<_Types...>& __v){
    return get<__type_index<_Type,_Types...>::__value>(__v);
}

template<ptrdiff_t _Index,typename ... _Types>
typename __indexed_type<_Index,_Types...>::__type& get(variant<_Types...>& __v){
    if(_Index!=__v.index())
        throw bad_variant_access("Bad variant index in get");
    return __variant_accessor<_Index,_Types...>::get(__v);
}

}
}

#endif
